[19.456449, "o", "d::string command = \"ps --ppid \" + std::to_string(pid);\r\n\r\n  FILE *ps = popen(command.c_str(), \"r\");\r\n  if (!ps) {\r\n    perror(\"popen\");\r\n    exit(1);\r\n  }\r\n\r\n  // size keeps track of the amount of lines. The first one will be the header.\r\n  int size = 0;\r\n  char buffer[1024];\r\n  while (fgets(buffer, sizeof(buffer), ps) != NULL) {\r\n    std::cout << buffer;\r\n    size++;\r\n  }\r\n\r\n  pclose(ps);\r\n\r\n  adjustScore(size == 2, 5, externalScore);\r\n\r\n  EXPECT_EQ(size, 2);\r\n}\r\n\r\nTEST_F(ShellTest, TestForkInBackground) {\r\n\r\n  int writeStatus1 = writeInput(\"sleep 10 &\\n\", false);\r\n  if (writeStatus1 == -1)\r\n    exit(1);\r\n\r\n  getOutput();\r\n\r\n  int writeStatus2 = writeInput(\"sleep 10 &\\n\", false);\r\n  if (writeStatus2 == -1)\r\n    exit(1);\r\n\r\n  getOutput();\r\n\r\n  int writeStatus3 = writeInput(\"sleep 10 &\\n\", false);\r\n  if (writeStatus3 == -1)\r\n    exit(1);\r\n\r\n  getOutput();\r\n\r\n  int writeStatus4 = writeInput(\"sleep 10 &\\n\", true);\r\n  if (writeStatus4 == -1)\r\n    exit(1);\r\n\r\n  getOutput();\r\n\r\n  std::string command = \"ps --ppid \" + std::to_string(pid);\r\n\r\n  FILE *ps = popen(command.c_str(), \"r\");\r\n  if (!ps) {\r\n    perror(\"popen\");\r\n    exit(1);\r\n  }\r\n\r\n  std::regex regex(\"([0-9]+)\");\r\n  std::smatch num;\r\n\r\n  std::unordered_set<int> children{pid};\r\n\r\n  // size keeps track of the amount of lines. The first one will be the header.\r\n  int size = 0;\r\n  char buffer[1024];\r\n  while (fgets(buffer, sizeof(buffer), ps) != NULL) {\r\n    std::string child_pid(buffer);\r\n    if (std::regex_search(child_pid, num, regex)) {\r\n      if (children.count(std::stoi(num.str())))\r\n        break;\r\n      children.insert(std::stoi(num.str()));\r\n    }\r\n    size++;\r\n  }\r\n\r\n  pclose(ps);\r\n\r\n  adjustScore(size == 5, 5, externalScore);\r\n\r\n  EXPECT_EQ(size, 5);\r\n}\r\n\r\nTEST_F(ShellTest, TestForkMixed) {\r\n\r\n  int writeStatus = writeInput(\"sleep 10 &\\n\", false);\r\n  if (writeStatus == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int writeStatus1 = writeInput(\"sleep 10\\n\", false);\r\n  if (writeStatus1 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int writeStatus2 = writeInput(\"sleep 5\\n\", true);\r\n  if (writeStatus2 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  std::string command = \"ps --ppid \" + std::to_string(pid);\r\n\r\n  FILE *ps = popen(command.c_str(), \"r\");\r\n  if (!ps) {\r\n    perror(\"popen\");\r\n    exit(1);\r\n  }\r\n\r\n  std::regex regex(\"([0-9]+)\");\r\n  std::smatch num;\r\n\r\n  std::unordered_set<int> children{pid};\r\n\r\n  int size = 0;\r\n  char buffer[1024];\r\n  while (fgets(buffer, sizeof(buffer), ps) != NULL) {\r\n    std::string child_pid(buffer);\r\n    if (std::regex_search(child_pid, num, regex)) {\r\n      if (children.count(std::stoi(num.str())))\r\n        break;\r\n      children.insert(std::stoi(num.str()));\r\n    }\r\n    size++;\r\n  }\r\n\r\n  pclose(ps);\r\n\r\n  adjustScore(size == 3, 5, externalScore);\r\n\r\n  EXPECT_EQ(size, 3);\r\n}\r\n\r\nTEST_F(ShellTest, TestWait) {\r\n\r\n  int writeStatus = writeInput(\"sleep 10\\n\", false);\r\n  if (writeStatus == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int writeStatus1 = writeInput(\"ping\\n\", false);\r\n  if (writeStatus1 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int writeStatus2 = writeInput(\"sleep 5\\n\", false);\r\n  if (writeStatus2 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  std::string command = \"ps --ppid \" + std::to_string(pid);\r\n\r\n  FILE *ps = popen(command.c_str(), \"r\");\r\n  if (!ps) {\r\n    perror(\"popen\");\r\n    exit(1);\r\n  }\r\n\r\n  int size = 0;\r\n  char buffer[1024];\r\n  while (fgets(buffer, sizeof(buffer), ps) != NULL) {\r\n    std::cout << buffer;\r\n    size++;\r\n  }\r\n\r\n  pclose(ps);\r\n\r\n  adjustScore(size == 2, 5, externalScore);\r\n\r\n  EXPECT_EQ(size, 2);\r\n}\r\n\r\nTEST_F(ShellTest, InvalidExecCommand) {\r\n\r\n  char * cwd_buf = getcwd(NULL, 0);\r\n  std::string expected_output = cwd_buf;\r\n  free(cwd_buf);\r\n\r\n  expected_output += \"$ \";\r\n  expected_output += expected_output;\r\n\r\n  int writeStatus = writeInput(\"la adf\\n\", true);\r\n  if (writeStatus == -1)\r\n    exit(1);\r\n\r\n  std::string output = getOutput();\r\n  std::string errLine = getErrOutput();\r\n\r\n  ASSERT_TRUE(output == expected_output);\r\n  ASSERT_TRUE(errLine == \"shell: unable to execute command\\n\");\r\n  adjustScore(output == expected_output, 2,"]
[19.456511, "o", " externalScore);\r\n  adjustScore(errLine == \"shell: unable to execute command\\n\", 3,\r\n              externalScore);\r\n}\r\n\r\nTEST_F(ShellTest, TestInvalidCommand) {\r\n\r\n  char * cwd_buf = getcwd(NULL, 0);\r\n  std::string expected_output = cwd_buf;\r\n  free(cwd_buf);\r\n\r\n  expected_output += \"$ \";\r\n  expected_output += expected_output;\r\n\r\n  int writeStatus = writeInput(\"Invalid Command\\n\", true);\r\n  if (writeStatus == -1)\r\n    exit(1);\r\n\r\n  std::string output = getOutput();\r\n  std::string errLine = getErrOutput();\r\n\r\n  ASSERT_TRUE(expected_output == output);\r\n  ASSERT_TRUE(errLine == \"shell: unable to execute command\\n\");\r\n  adjustScore(expected_output == output, 2, externalScore);\r\n  adjustScore(errLine == \"shell: unable to execute command\\n\", 2,\r\n              externalScore);\r\n}\r\n\r\n/* -------------------------- Internal Tests ----------------------------- */\r\n\r\nTEST_F(ShellTest, Pwd) {\r\n\r\n  int writeStatus = writeInput(\"pwd\\n\", true);\r\n  if (writeStatus == -1)\r\n    exit(1);\r\n\r\n  std::string output = getOutput();\r\n\r\n  char cwd[1024];\r\n  if (getcwd(cwd, sizeof(cwd)) != NULL) {\r\n    std::string expected_output = cwd;\r\n    adjustScore(parsedOutput(output) == expected_output, 3, internalScore);\r\n    EXPECT_EQ(parsedOutput(output), expected_output);\r\n  }\r\n}\r\n\r\nTEST_F(ShellTest, PwdWithArgument) {\r\n\r\n  int writeStatus = writeInput(\"pwd argument\\n\", true);\r\n  if (writeStatus == -1)\r\n    exit(1);\r\n\r\n  std::string errLine = getErrOutput();\r\n\r\n  ASSERT_TRUE(errLine == \"pwd: too many arguments\\n\");\r\n  adjustScore(errLine == \"pwd: too many arguments\\n\", 2, internalScore);\r\n}\r\n\r\nTEST_F(ShellTest, PathPrompt) {\r\n\r\n  int writeStatus = writeInput(\"pwd\\n\", true);\r\n  if (writeStatus == -1)\r\n    exit(1);\r\n\r\n  std::string output = getOutput();\r\n\r\n  std::string firstLine;\r\n  std::getline(std::istringstream(output), firstLine);\r\n  auto end = firstLine.find(\"$\");\r\n  if (end == std::string::npos) {\r\n    std::cerr << \"Failed to find '$' in output\" << std::endl;\r\n    exit(1);\r\n  }\r\n\r\n  firstLine = firstLine.substr(0, end);\r\n\r\n  char cwd[1024];\r\n  if (getcwd(cwd, sizeof(cwd)) != NULL) {\r\n    std::string expected_output = cwd;\r\n    adjustScore(firstLine == expected_output, 2, internalScore);\r\n    EXPECT_EQ(firstLine, expected_output);\r\n  }\r\n}\r\n\r\nTEST_F(ShellTest, Exit) {\r\n\r\n  int writeStatus = writeInput(\"ls -l\\n\", false);\r\n  if (writeStatus == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int writeStatus1 = writeInput(\"exit\\n\", true);\r\n  if (writeStatus1 == -1)\r\n    exit(1);\r\n\r\n  // wait for the shell to finish executing with a timeout of 1 second\r\n  int status;\r\n  int timeout = 1;\r\n  int ret = waitpid(pid, &status, WNOHANG);\r\n  while (ret == 0 && timeout > 0) {\r\n    sleep(1);\r\n    timeout--;\r\n    ret = waitpid(pid, &status, WNOHANG);\r\n  }\r\n\r\n  if (ret == 0)\r\n    EXPECT_TRUE(false) << \"Shell did not exit within the timeout period\";\r\n\r\n  // Exit status of the shell program\r\n  if (WIFEXITED(status)) {\r\n    adjustScore(true, 3, internalScore);\r\n    EXPECT_EQ(WEXITSTATUS(status), 0);\r\n  } else {\r\n    EXPECT_TRUE(false) << \"Shell did not exit normally\";\r\n  }\r\n}\r\n\r\nTEST_F(ShellTest, ExitWithArgument) {\r\n\r\n  int writeStatus = writeInput(\"exit argument\\n\", true);\r\n  if (writeStatus == -1)\r\n    exit(1);\r\n\r\n  std::string errLine = getErrOutput();\r\n\r\n  ASSERT_TRUE(errLine == \"exit: too many arguments\\n\");\r\n  adjustScore(errLine == \"exit: too many arguments\\n\", 2, internalScore);\r\n}\r\n\r\nTEST_F(ShellTest, CdForward) {\r\n  // Create a temporary directory\r\n  int create = mkdir(\"testdir\", S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\r\n\r\n  // Change directory\r\n  int writeStatus = writeInput(\"cd testdir\\n\", true);\r\n  if (writeStatus == -1)\r\n    exit(1);\r\n\r\n  std::string output = getOutput();\r\n\r\n  auto start = output.find(\"$\");\r\n  if (start == std::string::npos) {\r\n    std::cerr << \"Failed to find '$' in output\" << std::endl;\r\n    exit(1);\r\n  }\r\n\r\n  output = output.substr(start + 2);\r\n\r\n  char cwd[1024];\r\n  if (getcwd(cwd, sizeof(cwd)) != NULL) {\r\n    std::string expected_output = cwd;\r\n    adjustScore(output == expected_output + \"/testdir$ \", 3, internalScore);\r\n    EXPECT_EQ(output, ex"]
[19.458436, "o", "pected_output + \"/testdir$ \");\r\n  }\r\n\r\n  // cleanup\r\n  int remove = rmdir(\"testdir\");\r\n}\r\n\r\nTEST_F(ShellTest, CdBackward) {\r\n  // Save the current working directory\r\n  char cwd[1024];\r\n  if (getcwd(cwd, sizeof(cwd)) == NULL) {\r\n    // getCwd failed\r\n  }\r\n  std::string current_dir = cwd;\r\n\r\n  int writeStatus = writeInput(\"cd ..\\n\", true);\r\n  if (writeStatus == -1)\r\n    exit(1);\r\n\r\n  std::string output = getOutput();\r\n\r\n  auto start = output.find(\"$\");\r\n  if (start == std::string::npos) {\r\n    std::cerr << \"Failed to find '$' in output\" << std::endl;\r\n    exit(1);\r\n  }\r\n\r\n  output = output.substr(start + 2);\r\n\r\n  if (getcwd(cwd, sizeof(cwd)) != NULL) {\r\n    std::string expected_output =\r\n        current_dir.substr(0, current_dir.find_last_of(\"/\\\\\"));\r\n    adjustScore(output == expected_output + \"$ \", 2, internalScore);\r\n    EXPECT_EQ(output, expected_output + \"$ \");\r\n  }\r\n}\r\n\r\nTEST_F(ShellTest, CDInvalidArgument) {\r\n  int writeStatus = writeInput(\"cd sgdrerg\\n\", true);\r\n  if (writeStatus == -1)\r\n    exit(1);\r\n\r\n  std::string errLine = getErrOutput();\r\n\r\n  ASSERT_TRUE(errLine == \"cd: unable to change directory\\n\");\r\n  adjustScore(errLine == \"cd: unable to change directory\\n\", 2, internalScore);\r\n}\r\n\r\nTEST_F(ShellTest, InternalHelpCommand) {\r\n\r\n  std::string expected_output = \"cd: change the current directory\";\r\n\r\n  int writeStatus1 = writeInput(\"help cd\\n\", true);\r\n  if (writeStatus1 == -1)\r\n    exit(1);\r\n  std::string output = getOutput();\r\n\r\n  bool found = true;\r\n  if (output.find(expected_output) == std::string::npos)\r\n    found = false;\r\n\r\n  adjustScore(found, 1, internalScore);\r\n  EXPECT_TRUE(found);\r\n}\r\n\r\nTEST_F(ShellTest, ExternalHelpCommand) {\r\n\r\n  std::string expected_output = \"echo: external command or application\";\r\n\r\n  int writeStatus2 = writeInput(\"help echo\\n\", true);\r\n  if (writeStatus2 == -1)\r\n    exit(1);\r\n  std::string output = getOutput();\r\n\r\n  bool found = true;\r\n  if (output.find(expected_output) == std::string::npos)\r\n    found = false;\r\n\r\n  adjustScore(found, 1, internalScore);\r\n  EXPECT_TRUE(found);\r\n}\r\n\r\nTEST_F(ShellTest, HelpCommandNoArgument) {\r\n\r\n  std::vector<std::string> commands = {\"help\", \"cd\", \"exit\", \"pwd\", \"history\"};\r\n\r\n  int status = writeInput(\"help\\n\", true);\r\n  if (status == -1)\r\n    exit(1);\r\n  std::string output = getOutput();\r\n\r\n  bool all_commands_found = true;\r\n  for (const std::string &command : commands) {\r\n    if (output.find(command) == std::string::npos) {\r\n      all_commands_found = false;\r\n      break;\r\n    }\r\n  }\r\n  adjustScore(all_commands_found, 3, internalScore);\r\n  EXPECT_TRUE(all_commands_found);\r\n}\r\n\r\n/* -------------------------- History Tests ----------------------------- */\r\n\r\n// Displays the last 10 commands\r\nTEST_F(ShellTest, DisplayLast10Commands) {\r\n  std::vector<std::string> commands{\"echo Hello World\\n\",\r\n                                    \"ls -l\\n\",\r\n                                    \"pwd\\n\",\r\n                                    \"du\\n\",\r\n                                    \"ls\\n\",\r\n                                    \"clear\\n\",\r\n                                    \"ps\\n\",\r\n                                    \"ls\\n\",\r\n                                    \"pwd\\n\",\r\n                                    \"help\\n\",\r\n                                    \"pwd\\n\",\r\n                                    \"help\\n\"};\r\n  for (auto command : commands) {\r\n    int writeStatus = writeInput(command.c_str(), false);\r\n    if (writeStatus == -1)\r\n      exit(1);\r\n    getOutput();\r\n  }\r\n\r\n  int status = writeInput(\"history\\n\", true);\r\n  if (status == -1)\r\n    exit(1);\r\n  std::string output = getOutput();\r\n\r\n  char cwd[1024];\r\n  if (getcwd(cwd, sizeof(cwd)) == NULL) {\r\n    // getCwd failed\r\n  }\r\n  std::string current_dir = cwd;\r\n\r\n  std::string expected_output = \"12\\thistory\\n11\\thelp\\n10\\tpwd\\n9\\thelp\\n8\\tpw\"\r\n                                \"d\\n7\\tls\\n6\\tps\\n5\\tclear\\n4\\tls\\n3\\tdu\\n\" +\r\n                                current_dir + \"$ \";\r\n\r\n  EXPECT_EQ(expected_output, output);\r\n\r\n  adjustScore(expected_output == output, 3, historyScore);\r\n}\r\n\r\n// Displays arguments\r\nTEST_F(Shell"]
[19.458798, "o", "Test, DisplayArguments) {\r\n  std::vector<std::string> commands{\"echo Hello World\\n\", \"ls -l\\n\", \"ls -la\\n\",\r\n                                    \"du\\n\", \"ls -lah\\n\"};\r\n  for (auto command : commands) {\r\n    int writeStatus = writeInput(command.c_str(), false);\r\n    if (writeStatus == -1)\r\n      exit(1);\r\n    getOutput();\r\n  }\r\n\r\n  int status = writeInput(\"history\\n\", true);\r\n  if (status == -1)\r\n    exit(1);\r\n  std::string output = getOutput();\r\n\r\n  char cwd[1024];\r\n  if (getcwd(cwd, sizeof(cwd)) == NULL) {\r\n    // getCwd failed\r\n  }\r\n  std::string current_dir = cwd;\r\n\r\n  std::string expected_output = \"5\\thistory\\n4\\tls -lah\\n3\\tdu\\n2\\tls \"\r\n                                \"-la\\n1\\tls -l\\n0\\techo Hello World\\n\" +\r\n                                current_dir + \"$ \";\r\n\r\n  EXPECT_EQ(expected_output, output);\r\n\r\n  adjustScore(expected_output == output, 2, historyScore);\r\n}\r\n\r\n// Minimum command starts at 0\r\nTEST_F(ShellTest, MinimumCommandNumber) {\r\n  std::vector<char> numbers{'3', '2', '1', '0'};\r\n\r\n  int status1 = writeInput(\"echo Hello World\\n\", false);\r\n  if (status1 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int status2 = writeInput(\"ls\\n\", false);\r\n  if (status2 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int status3 = writeInput(\"pwd\\n\", false);\r\n  if (status3 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  // Check the command history\r\n  int status = writeInput(\"history\\n\", true);\r\n  if (status == -1)\r\n    exit(1);\r\n  std::string output = getOutput();\r\n\r\n  std::istringstream iss(output);\r\n  std::string line;\r\n  bool numbering = true;\r\n  int i = 0;\r\n  for (int i = 0; i < numbers.size(); i++) {\r\n    std::getline(iss, line);\r\n    numbering = (line[0] == numbers[i]) && numbering;\r\n  }\r\n  adjustScore(numbering, 3, historyScore);\r\n  ASSERT_TRUE(numbering);\r\n}\r\n\r\n// Commands listed in reverse order\r\nTEST_F(ShellTest, CommandReverseOrder) {\r\n  std::stack<std::string> stack;\r\n  int status1 = writeInput(\"pwd\\n\", false);\r\n  if (status1 == -1)\r\n    exit(1);\r\n  getOutput();\r\n  stack.push(\"0\\tpwd\");\r\n  int status2 = writeInput(\"ls\\n\", false);\r\n  if (status2 == -1)\r\n    exit(1);\r\n  getOutput();\r\n  stack.push(\"1\\tls\");\r\n\r\n  // Check the command history\r\n  int status = writeInput(\"history\\n\", true);\r\n  if (status == -1)\r\n    exit(1);\r\n  std::string output = getOutput();\r\n  stack.push(\"2\\thistory\");\r\n\r\n  std::istringstream iss(output);\r\n  std::string line;\r\n  bool commandReverse = true;\r\n  while (!stack.empty()) {\r\n    std::string command = stack.top();\r\n    stack.pop();\r\n    std::getline(iss, line);\r\n    commandReverse = (command == line) && commandReverse;\r\n    EXPECT_EQ(command, line);\r\n  }\r\n  adjustScore(commandReverse, 3, historyScore);\r\n}\r\n\r\nTEST_F(ShellTest, CorrectCommandNumber) {\r\n  std::vector<std::string> commands{\"echo Hello World\\n\",\r\n                                    \"ls -l\\n\",\r\n                                    \"pwd\\n\",\r\n                                    \"du\\n\",\r\n                                    \"ls\\n\",\r\n                                    \"ds\\n\",\r\n                                    \"ps\\n\",\r\n                                    \"top\\n\",\r\n                                    \"pwd\\n\",\r\n                                    \"help\\n\",\r\n                                    \"pwd\\n\",\r\n                                    \"help\\n\"};\r\n  for (int i = 0; i < 19; i++) {\r\n    int writeStatus = writeInput(\"pwd\\n\", false);\r\n    if (writeStatus == -1)\r\n      exit(1);\r\n    getOutput();\r\n  }\r\n\r\n  int status = writeInput(\"history\\n\", true);\r\n  if (status == -1)\r\n    exit(1);\r\n  std::string output = getOutput();\r\n\r\n  std::istringstream iss(output);\r\n  std::string line;\r\n  bool correctNumbering = true;\r\n  for (int i = 19; i >= 10; i--) {\r\n    std::getline(iss, line);\r\n    int num = std::stoi(line.substr(0, 2));\r\n    correctNumbering = (i == num) && correctNumbering;\r\n  }\r\n  adjustScore(correctNumbering, 4, historyScore);\r\n  ASSERT_TRUE(correctNumbering);\r\n}\r\n\r\nTEST_F(ShellTest, ReRunPreviousCommand) {\r\n  std::string output;\r\n\r\n  int status1 = writeInput(\"echo test\\n\", false);\r\n  if (status1 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int status2 "]
[19.459927, "o", "= writeInput(\"!!\\n\", true);\r\n  if (status2 == -1)\r\n    exit(1);\r\n  output = getOutput();\r\n\r\n  std::istringstream iss(output);\r\n  std::string firstLine;\r\n  std::string secondLine;\r\n  std::getline(iss, firstLine);\r\n  std::getline(iss, secondLine);\r\n  bool commandShown = firstLine.find(\"echo test\") != std::string::npos;\r\n  bool commandOutput = firstLine.find(\"test\") != std::string::npos;\r\n  adjustScore(commandShown && commandOutput, 2, historyScore);\r\n  ASSERT_TRUE(commandShown);\r\n  ASSERT_TRUE(commandOutput);\r\n}\r\n\r\nTEST_F(ShellTest, ReRunNthCommand) {\r\n  std::string output;\r\n  std::string expected_output;\r\n\r\n  int status1 = writeInput(\"echo Hello World!\\n\", false);\r\n  if (status1 == -1)\r\n    exit(1);\r\n  expected_output = getOutput();\r\n\r\n  int status2 = writeInput(\"ls\\n\", false);\r\n  if (status2 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int status3 = writeInput(\"pwd\\n\", false);\r\n  if (status3 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int status4 = writeInput(\"!0\\n\", true);\r\n  if (status4 == -1)\r\n    exit(1);\r\n  output = getOutput();\r\n\r\n  std::istringstream iss(output);\r\n  std::string firstLine;\r\n  std::string secondLine;\r\n\r\n  std::getline(iss, firstLine);\r\n  std::getline(iss, secondLine);\r\n\r\n  bool command = firstLine == \"echo Hello World!\";\r\n  bool command_output = secondLine == \"Hello World!\";\r\n\r\n  ASSERT_TRUE(command);\r\n  ASSERT_TRUE(command_output);\r\n\r\n  adjustScore(command && command_output, 2, historyScore);\r\n}\r\n\r\nTEST_F(ShellTest, ReRunCommandInHistory) {\r\n  std::stack<std::string> stack;\r\n  std::string output;\r\n  std::string expected_output;\r\n  int status1 = writeInput(\"ls\\n\", false);\r\n  if (status1 == -1)\r\n    exit(1);\r\n  getOutput();\r\n  stack.push(\"0\\tls\");\r\n\r\n  int status2 = writeInput(\"pwd\\n\", false);\r\n  if (status2 == -1)\r\n    exit(1);\r\n  getOutput();\r\n  stack.push(\"1\\tpwd\");\r\n\r\n  int status3 = writeInput(\"echo Hello World from my shell!\\n\", false);\r\n  if (status3 == -1)\r\n    exit(1);\r\n  getOutput();\r\n  stack.push(\"2\\techo Hello World from my shell!\");\r\n\r\n  int status4 = writeInput(\"!1\\n\", false);\r\n  if (status4 == -1)\r\n    exit(1);\r\n  output = getOutput();\r\n  stack.push(\"3\\tpwd\");\r\n\r\n  int status5 = writeInput(\"!0\\n\", false);\r\n  if (status5 == -1)\r\n    exit(1);\r\n  output = getOutput();\r\n  stack.push(\"4\\tls\");\r\n\r\n  int status6 = writeInput(\"history\\n\", true);\r\n  if (status6 == -1)\r\n    exit(1);\r\n  output = getOutput();\r\n  stack.push(\"5\\thistory\");\r\n\r\n  std::istringstream iss(output);\r\n  std::string line;\r\n  bool commandInHistory = true;\r\n  while (!stack.empty()) {\r\n    std::string command = stack.top();\r\n    stack.pop();\r\n    std::getline(iss, line);\r\n    commandInHistory = (line == command) && commandInHistory;\r\n    EXPECT_EQ(line, command);\r\n  }\r\n  adjustScore(commandInHistory, 2, historyScore);\r\n  ASSERT_TRUE(commandInHistory);\r\n}\r\n\r\nTEST_F(ShellTest, IllegalHistoryCommand) {\r\n  int status1 = writeInput(\"ls\\n\", false);\r\n  if (status1 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int status2 = writeInput(\"pwd\\n\", false);\r\n  if (status2 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int status3 = writeInput(\"!hi\\n\", false);\r\n  if (status3 == -1)\r\n    exit(1);\r\n  std::string output = getErrOutput();\r\n\r\n  std::istringstream iss(output);\r\n  std::string line;\r\n  std::getline(iss, line);\r\n\r\n  // make sure the first line isn't the command prompt. Should be an error\r\n  // message instead\r\n  char * cwd_buf = getcwd(NULL, 0);\r\n  bool errorCommand =\r\n      (line.find(cwd_buf) == std::string::npos) && line.size() != 0;\r\n  free(cwd_buf);\r\n\r\n  ASSERT_TRUE(errorCommand);\r\n\r\n  int status4 = writeInput(\"history\\n\", true);\r\n  if (status4 == -1)\r\n    exit(1);\r\n  std::string out = getOutput();\r\n\r\n  std::istringstream is(out);\r\n  std::string out_line;\r\n  int num_of_lines = 0;\r\n  while (std::getline(is, out_line))\r\n    num_of_lines++;\r\n\r\n  adjustScore(num_of_lines == 4, 2, historyScore);\r\n  EXPECT_EQ(num_of_lines, 4);\r\n}\r\n\r\nTEST_F(ShellTest, IllegalNthCommand) {\r\n  int status1 = writeInput(\"ls\\n\", false);\r\n  if (status1 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int status2 = writeInput(\"pwd\\n\", false);\r\n  if (status2 == -1)\r\n    exit(1);\r\n"]
[19.460483, "o", "  getOutput();\r\n\r\n  int status3 = writeInput(\"!-1\\n\", false);\r\n  if (status3 == -1)\r\n    exit(1);\r\n  std::string output = getErrOutput();\r\n\r\n  std::istringstream iss(output);\r\n  std::string line;\r\n  std::getline(iss, line);\r\n\r\n  // make sure the first line isn't the command prompt. Should be an error\r\n  // message instead\r\n  \r\n  char * cwd_buf = getcwd(NULL, 0);\r\n  bool errorCommand =\r\n      line.find(cwd_buf) == std::string::npos && line.size() != 0;\r\n  free(cwd_buf);\r\n\r\n  ASSERT_TRUE(errorCommand);\r\n\r\n  int status4 = writeInput(\"history\\n\", true);\r\n  if (status4 == -1)\r\n    exit(1);\r\n  std::string out = getOutput();\r\n\r\n  std::istringstream is(out);\r\n  std::string out_line;\r\n  int num_of_lines = 0;\r\n  while (std::getline(is, out_line))\r\n    num_of_lines++;\r\n\r\n  adjustScore(num_of_lines == 4, 2, historyScore);\r\n  EXPECT_EQ(num_of_lines, 4);\r\n}\r\n\r\nTEST_F(ShellTest, CtrlCInformation) {\r\n  std::string output;\r\n  bool score = true;\r\n  getOutput();\r\n\r\n  int status = kill(pid, SIGINT);\r\n\r\n  // Check that the signal was correctly sent\r\n  EXPECT_EQ(status, 0);\r\n\r\n  output = getOutput();\r\n\r\n  EXPECT_TRUE(output.find(\"help\") != std::string::npos);\r\n  score = (output.find(\"help\") != std::string::npos) && score;\r\n  EXPECT_TRUE(output.find(\"cd\") != std::string::npos);\r\n  score = (output.find(\"cd\") != std::string::npos) && score;\r\n  EXPECT_TRUE(output.find(\"exit\") != std::string::npos);\r\n  score = (output.find(\"exit\") != std::string::npos) && score;\r\n  EXPECT_TRUE(output.find(\"pwd\") != std::string::npos);\r\n  score = (output.find(\"pwd\") != std::string::npos) && score;\r\n  EXPECT_TRUE(output.find(\"history\") != std::string::npos);\r\n  score = (output.find(\"history\") != std::string::npos) && score;\r\n\r\n  // Check that the shell has resumed normal operation and is showing the\r\n  // command prompt\r\n  char cwd[1024];\r\n  if (getcwd(cwd, sizeof(cwd)) != NULL) {\r\n    std::string current_dir = cwd;\r\n    std::string expected_output = current_dir + \"$ \";\r\n    EXPECT_TRUE(output.find(expected_output) != std::string::npos);\r\n    score = (output.find(expected_output) != std::string::npos) && score;\r\n  }\r\n  adjustScore(score, 5, historyScore);\r\n  std::cout << \"success \" << std::endl;\r\n}\r\n\r\nTEST_F(ShellTest, CtrlCNoCrash) {\r\n  getOutput();\r\n\r\n  int signal_status = kill(pid, SIGINT);\r\n\r\n  // Check that the signal was correctly sent\r\n  EXPECT_EQ(signal_status, 0);\r\n\r\n  int status;\r\n  int timeout = 1;\r\n  int ret = waitpid(pid, &status, WNOHANG);\r\n  while (ret == 0 && timeout > 0) {\r\n    sleep(1);\r\n    timeout--;\r\n    ret = waitpid(pid, &status, WNOHANG);\r\n  }\r\n\r\n  if (ret != 0)\r\n    EXPECT_TRUE(false) << \"Shell exited\";\r\n\r\n  // Exit status of the shell program\r\n  if (ret == pid && WIFEXITED(status)) {\r\n    EXPECT_TRUE(false) << \"Shell exited\";\r\n  }\r\n  else {\r\n    adjustScore(true, 2, historyScore);\r\n  }\r\n}\r\n\r\nTEST_F(ShellTest, CDWithoutArgument) {\r\n  std::string output;\r\n  std::string home_path;\r\n\r\n  int status1 = writeInput(\"cd\\n\", false);\r\n  if (status1 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int status2 = writeInput(\"pwd\\n\", false);\r\n  if (status2 == -1)\r\n    exit(1);\r\n  output = getOutput();\r\n  home_path = getenv(\"HOME\");\r\n\r\n  adjustScore(output.find(home_path) != std::string::npos, 3, internalScore);\r\n  ASSERT_TRUE(output.find(home_path) != std::string::npos);\r\n}\r\n\r\nTEST_F(ShellTest, CDHome) {\r\n  std::string output;\r\n  std::string home_path;\r\n\r\n  int status1 = writeInput(\"cd ~\\n\", false);\r\n  if (status1 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int status2 = writeInput(\"pwd\\n\", false);\r\n  if (status2 == -1)\r\n    exit(1);\r\n  output = getOutput();\r\n  home_path = getenv(\"HOME\");\r\n\r\n  adjustScore(output.find(home_path) != std::string::npos, 3, internalScore);\r\n  ASSERT_TRUE(output.find(home_path) != std::string::npos);\r\n}\r\n\r\nTEST_F(ShellTest, ChangeToHomeDirectory) {\r\n  std::string output;\r\n  std::string home_path = getenv(\"HOME\");\r\n  std::string directory_path = home_path + \"/testdir\";\r\n  std::string expected_output = directory_path;\r\n\r\n  int create =\r\n      mkdir(directory_path.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\r\n\r\n  int status1 = writeIn"]
[19.460536, "o", "put(\"cd ~/testdir\\n\", false);\r\n  if (status1 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int status2 = writeInput(\"pwd\\n\", true);\r\n  if (status2 == -1)\r\n    exit(1);\r\n  output = getOutput();\r\n\r\n  adjustScore(output.find(expected_output) != std::string::npos, 4,\r\n              internalScore);\r\n  ASSERT_TRUE(output.find(expected_output) != std::string::npos);\r\n\r\n  int remove = rmdir(directory_path.c_str());\r\n}\r\n\r\nTEST_F(ShellTest, cdBack) {\r\n  std::string output;\r\n  std::string prev_path;\r\n  std::string intermediate;\r\n\r\n  int status1 = writeInput(\"pwd\\n\", false);\r\n  if (status1 == -1)\r\n    exit(1);\r\n  prev_path = getOutput();\r\n\r\n  int status2 = writeInput(\"cd /usr\\n\", false);\r\n  if (status2 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int status3 = writeInput(\"pwd\\n\", false);\r\n  if (status3 == -1)\r\n    exit(1);\r\n  intermediate = getOutput();\r\n\r\n  ASSERT_TRUE(intermediate.find(parsedOutput(prev_path)) == std::string::npos);\r\n\r\n  int status4 = writeInput(\"cd -\\n\", false);\r\n  if (status4 == -1)\r\n    exit(1);\r\n  getOutput();\r\n\r\n  int status5 = writeInput(\"pwd\\n\", true);\r\n  if (status5 == -1)\r\n    exit(1);\r\n  output = getOutput();\r\n\r\n  int end = output.find('\\n');\r\n  output = output.substr(0, end);\r\n\r\n  adjustScore(output.find(parsedOutput(prev_path)) != std::string::npos, 5,\r\n              internalScore);\r\n  ASSERT_TRUE(output.find(parsedOutput(prev_path)) != std::string::npos);\r\n}\r\n\r\nint main(int argc, char **argv) {\r\n  testing::InitGoogleTest(&argc, argv);\r\n  int result = RUN_ALL_TESTS();\r\n  std::cout << \"External: \" << externalScore << std::endl;\r\n  std::cout << \"Internal: \" << internalScore << std::endl;\r\n  std::cout << \"History: \" << historyScore << std::endl;\r\n  int total = externalScore + internalScore + historyScore;\r\n  std::cout << \"Final score: \" << total << std::endl;\r\n  return result;\r\n}\r\n\u001b[1m\u001b[7m%\u001b[27m\u001b[1m\u001b[0m                                                                                                                         \r \r\u001b]2;cmpt201@10360e5d85f7:~/units/04-long-assignments/a8-pnotato/gtest\u0007\u001b]1;..pnotato/gtest\u0007"]

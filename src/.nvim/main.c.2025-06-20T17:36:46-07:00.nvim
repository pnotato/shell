#define _GNU_SOURCE
#define MAX_COMMAND_SIZE 4096
#include "../include/msgs.h"
#include <errno.h>
#include <limits.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>


#define MAX_COMMAND_SIZE 4096



void run_line(char *line);
void kill_zombies();

void shell() {
  printf("ASOHFI");
  char current_line[MAX_COMMAND_SIZE];
  ssize_t command_size;

  // Variables for cwd
  char cwd_buf[PATH_MAX];

  while (true) {
    // Current Working Directory and shell stuff
    char *cwd_ptr = getcwd(cwd_buf, sizeof(cwd_buf));

    if (cwd_ptr == NULL) {
      const char *err = FORMAT_MSG("shell", GETCWD_ERROR_MSG);
      write(STDERR_FILENO, err, strlen(err));
      cwd_ptr = "";
    }
    printf("%s$ ",
           cwd_ptr); // For reference, this is the shell path that's printed
    command_size = read(STDIN_FILENO, current_line, MAX_COMMAND_SIZE);
    if (command_size < 0) {
      const char *file_err = FORMAT_MSG("shell", GETCWD_ERROR_MSG);
      write(STDERR_FILENO, file_err, strlen(file_err));
      continue;
    }
    current_line[command_size] = '\0';

    run_line(current_line);
    // NEED A FREE FOR THE LINE THATS PASSED TO RUN_LINE
  }
}

// Foreground Execution
void run_line(char *line) {
  char *commands[4096]; // CHANGE THIS LATER ON
  char *saveptr;
  char *token = strtok_r(line, " \n", &saveptr);
  int i = 0;
  bool is_background = false;

  while (token != NULL) {
    commands[i++] = token;
    token = strtok_r(NULL, " \n", &saveptr);
  }
  if (i > 0 && strcmp(commands[i - 1], "&") == 0) {
    printf("DEBUG: BACKGROUND MODE ON");
    is_background = true;
    commands[i - 1] = NULL;
  } else {
    commands[i] = NULL;
  };

  if (commands[0] == NULL) {
    return;
  } // Checks if the array is empty. if it is, immediately return

  pid_t pid = fork();

  if (pid == -1) {
    const char *err = FORMAT_MSG("shell", FORK_ERROR_MSG);
    write(STDERR_FILENO, err, strlen(err)); // MAYBE CHANGE TO OUT?
  } else if (pid == 0 && commands[0] != NULL) {

    if (execvp(commands[0], commands) == -1) {
      // I think we use execvp so a path doesn't need to be specified
      // also because our arguments are in an array
      const char *err = FORMAT_MSG("shell", EXEC_ERROR_MSG);
      write(STDERR_FILENO, err, strlen(err));
    }

  } else {
    int wstatus = 0;
    if (!is_background) {
      if (waitpid(pid, &wstatus, 0) == -1) {
        // char *err = "shell: unable to wait for child\n";
        const char *err = FORMAT_MSG("shell", WAIT_ERROR_MSG);
        write(STDERR_FILENO, err, strlen(err));
      }
      kill_zombies();
    }
  }
}

// kills all currently running child processes.
// DEBUG: Check over later.
void kill_zombies() {
  int wstatus;
  while (waitpid(-1, &wstatus, WNOHANG) > 0) {
    continue;
  }
}

// Background Execution

int main() {
  shell();
  return 0;
}

#define _GNU_SOURCE
#include "../include/msgs.h"
#include <errno.h>
#include <limits.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

void run_line(char *line);
void kill_zombies();

void shell() {
  char *current_line = NULL;
  size_t len = 0;
  ssize_t nread;

  // Variables for cwd
  char cwd_buf[PATH_MAX];

  while (true) {

    // Current Working Directory and shell stuff
    char *cwd_ptr = getcwd(cwd_buf, sizeof(cwd_buf));

    if (cwd_ptr == NULL) {
      printf("shell: unable to get current directory\n");
      cwd_ptr = "";
    }
    printf("%s$ ",
           cwd_ptr); // For reference, this is the shell path that's printed
    nread = getline(&current_line, &len, stdin);
    // printf("%s\n", current_line);

    run_line(current_line);
    // NEED A FREE FOR THE LINE THATS PASSED TO RUN_LINE
  }
}

// Foreground Execution
void run_line(char *line) {
  char *commands[4096]; // CHANGE THIS LATER ON
  char *saveptr;
  char *token = strtok_r(line, " \n", &saveptr);
  int i = 0;
  bool is_background = false;

  while (token != NULL) {
    commands[i++] = token;
    token = strtok_r(NULL, " \n", &saveptr);
  }
  if (i > 0 && strcmp(commands[i - 1], "&") == 0) {
    printf("DEBUG: BACKGROUND MODE ON");
    is_background = true;
    commands[i - 1] = NULL;
  } else if (i > 0) {
    printf("DEBUG: NOTHING HAPPENED.");
  } else {
    commands[i] = NULL;
  };

  pid_t pid = fork();

  if (pid == -1) {
    char *err = "shell: unable to fork\n";
    write(STDERR_FILENO, err, strlen(err)); // MAYBE CHANGE TO OUT?
  } else if (pid == 0) {

    if (execvp(commands[0], commands) == -1) {
      // I think we use execvp so a path doesn't need to be specified
      // also because our arguments are in an array
      char *err = "shell: unable to execute command\n";
      write(STDERR_FILENO, err, strlen(err));
    }

  } else {
    int wstatus = 0;
    if (!is_background) {
      if (waitpid(pid, &wstatus, 0) == -1) {
      // char *err = "shell: unable to wait for child\n";
        const char* err = FORMAT_MSG()
        write(STDERR_FILENO, err, strlen(err));
      }
      kill_zombies();
    }
  }
}

// kills all currently running child processes.
// DEBUG: Check over later.
void kill_zombies() {
  int wstatus;
  while (waitpid(-1, &wstatus, WNOHANG) > 0) {
    continue;
  }
}

// Background Execution

int main() {
  shell();
  return 0;
}

#define _GNU_SOURCE
#include "../include/msgs.h"
#include <errno.h>
#include <limits.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

#define MAX_COMMAND_SIZE 4096
#define MAX_HISTORY_LEN 10

void run_line(char *line, char *cwd, char *cwd_prev);
void kill_zombies();
void handle_sigint();
void add_to_history(char *input, int *history_count, char **input_history);
void remove_oldest_record(int *history_count, char **input_history);
void debug(char *line) { write(STDERR_FILENO, line, strlen(line)); }

void shell() {
  // Variables for cwd
  char current_line[MAX_COMMAND_SIZE];
  char cwd_buf[PATH_MAX];

  // Previous for cd -
  char cwd_prev[PATH_MAX];
  char *cwd_prev_ptr = cwd_prev;

  // History
  char *input_history[MAX_HISTORY_LEN];
  int history_count = 0;
  int history_numbers;

  struct sigaction handler;
  handler.sa_handler = handle_sigint;
  sigemptyset(&handler.sa_mask);
  handler.sa_flags = 0;
  sigaction(SIGINT, &handler, NULL);

  while (true) {
    // Current Working Directory and shell stuff
    char *cwd_ptr = getcwd(cwd_buf, sizeof(cwd_buf));

    if (cwd_ptr == NULL) {
      const char *err = FORMAT_MSG("shell", GETCWD_ERROR_MSG);
      write(STDERR_FILENO, err, strlen(err));
      cwd_ptr = "";
    }
    const char *shell_sign = "$ ";
    write(STDOUT_FILENO, cwd_ptr,
          strlen(
              cwd_ptr)); // For reference, this is the shell path that's printed
    write(STDOUT_FILENO, shell_sign, strlen(shell_sign));
    ssize_t command_size = read(STDIN_FILENO, current_line, MAX_COMMAND_SIZE);
    if (command_size == -1) {
      if (errno == EINTR) {
        continue;
      }

    } else if (command_size == 0) {
      const char *file_err = FORMAT_MSG("shell", GETCWD_ERROR_MSG);
      write(STDERR_FILENO, file_err, strlen(file_err));
      continue;
    }
    current_line[command_size] = '\0';

    run_line(current_line, cwd_ptr, cwd_prev_ptr);
    // NEED A FREE FOR THE LINE THATS PASSED TO RUN_LINE
  }
}

// History
void add_to_history(char *input, int *history_count, char **input_history) {
  if (*history_count >= MAX_HISTORY_LEN) {
    remove_oldest_record(history_count, input_history);
  }
  input_history[*history_count] = input;
  (*history_count)++;
}

void remove_oldest_record(int *history_count, char **input_history) {
  if (history_count > 0) {
    free(input_history[0]);
    for (int i = 1; i < *history_count; i++) {
      input_history[i - 1] = input_history[i];
    }
    (*history_count)--;
  }
}

// Handle Siging
void handle_sigint() {
  const char *help_space = "\n";
  const char *help_msg0 = FORMAT_MSG("cd", CD_HELP_MSG);
  const char *help_msg1 = FORMAT_MSG("pwd", PWD_HELP_MSG);
  const char *help_msg2 = FORMAT_MSG("exit", EXIT_HELP_MSG);
  const char *help_msg3 = FORMAT_MSG("help", HELP_HELP_MSG);
  write(STDOUT_FILENO, help_space, strlen(help_space));
  write(STDOUT_FILENO, help_msg3, strlen(help_msg3));
  write(STDOUT_FILENO, help_msg1, strlen(help_msg1));
  write(STDOUT_FILENO, help_msg2, strlen(help_msg2));
  write(STDOUT_FILENO, help_msg0, strlen(help_msg0));
  return;
}

// Foreground Execution
void run_line(char *line, char *cwd, char *cwd_prev_ptr) {
  char *commands[4096]; // CHANGE THIS LATER ON
  memset(commands, 0, sizeof(commands));
  char *saveptr;
  char *token = strtok_r(line, " \n", &saveptr);
  int i = 0;
  bool is_background = false;

  kill_zombies();

  while (token != NULL) {
    commands[i++] = token;
    token = strtok_r(NULL, " \n", &saveptr);
  }
  if (i > 0 && strcmp(commands[i - 1], "&") == 0) {
    debug("DEBUG: BACKGROUND MODE ON");
    is_background = true;
    commands[i - 1] = NULL;
  } else {
    commands[i] = NULL;
  };

  // Checks if the array is empty. if it is, immediately return
  if (commands[0] == NULL) {
    return;
  }

  // Check if an internal command is run.
  if (strcmp(commands[0], "exit") == 0) {
    if (commands[1] == NULL) {
      exit(EXIT_SUCCESS);
    } else {
      const char *exit_cmd_err = FORMAT_MSG("exit", TMA_MSG);
      write(STDERR_FILENO, exit_cmd_err, strlen(exit_cmd_err));
      return;
    }
  } else if (strcmp(commands[0], "pwd") == 0) {
    char cwd_buf[PATH_MAX];
    char *cwd_ptr = getcwd(cwd_buf, sizeof(cwd_buf));
    const char *escape = "\n";

    if (cwd_ptr == NULL) {
      const char *err = FORMAT_MSG("pwd", GETCWD_ERROR_MSG);
      write(STDERR_FILENO, err, strlen(err));
      return;
    }
    if (commands[1] != NULL) {
      const char *err = FORMAT_MSG("pwd", TMA_MSG);
      write(STDERR_FILENO, err, strlen(err));
      return;
    }
    write(STDOUT_FILENO, cwd_ptr, strlen(cwd_ptr));
    write(STDOUT_FILENO, escape, strlen(escape));

    return;
  } else if (strcmp(commands[0], "cd") == 0) {
    // char cwd_buf[PATH_MAX];
    // char *cwd_ptr = getcwd(cwd_buf, sizeof(cwd_buf));
    char *new_path;
    char new_path_buf[PATH_MAX];
    if (commands[2] != NULL) {
      const char *err = FORMAT_MSG("cd", TMA_MSG);
      write(STDERR_FILENO, err, strlen(err));
      return;
    }
    if (commands[1] == NULL || strcmp(commands[1], "~") == 0) {
      new_path = "/home";
    } else if (commands[1][0] == '~') {
      // DEBUG: This still causes a warning, but should be safe.
      // Check later in case of memory leak.
      snprintf(new_path_buf, sizeof(new_path_buf), "/home%s", commands[1] + 1);
      new_path = new_path_buf;
    } else if (strcmp(commands[1], "-") == 0) {
      new_path = cwd_prev_ptr;
    } else {
      new_path = commands[1];
    }

    // Actual running of path
    if (chdir(new_path) == 0) {
      snprintf(cwd_prev_ptr, PATH_MAX, "%s", cwd);
      return;
    } else {
      const char *err = FORMAT_MSG("cd", CHDIR_ERROR_MSG);
      write(STDERR_FILENO, err, strlen(err));
    }
  } else if (strcmp(commands[0], "help") == 0) {
    if (commands[2] != NULL) {
      const char *help_cmd_err = FORMAT_MSG("help", TMA_MSG);
      write(STDERR_FILENO, help_cmd_err, strlen(help_cmd_err));
      return;
    }
    if (commands[1] == NULL) {
      const char *help_msg0 = FORMAT_MSG("cd", CD_HELP_MSG);
      const char *help_msg1 = FORMAT_MSG("pwd", PWD_HELP_MSG);
      const char *help_msg2 = FORMAT_MSG("exit", EXIT_HELP_MSG);
      const char *help_msg3 = FORMAT_MSG("help", HELP_HELP_MSG);
      write(STDOUT_FILENO, help_msg3, strlen(help_msg3));
      write(STDOUT_FILENO, help_msg1, strlen(help_msg1));
      write(STDOUT_FILENO, help_msg2, strlen(help_msg2));
      write(STDOUT_FILENO, help_msg0, strlen(help_msg0));
      return;
    } else if (strcmp(commands[1], "cd") == 0) {
      debug("HELP CD\n");
      const char *help_cd_msg = FORMAT_MSG("cd", CD_HELP_MSG);
      write(STDOUT_FILENO, help_cd_msg, strlen(help_cd_msg));
      return;
    } else if (strcmp(commands[1], "pwd") == 0) {
      const char *help_pwd_msg = FORMAT_MSG("pwd", PWD_HELP_MSG);
      write(STDOUT_FILENO, help_pwd_msg, strlen(help_pwd_msg));
      return;
    } else if (strcmp(commands[1], "exit") == 0) {
      const char *help_exit_msg = FORMAT_MSG("exit", EXIT_HELP_MSG);
      write(STDOUT_FILENO, help_exit_msg, strlen(help_exit_msg));
      return;
    } else if (strcmp(commands[1], "help") == 0) {
      const char *help_help_msg = FORMAT_MSG("help", HELP_HELP_MSG);
      write(STDOUT_FILENO, help_help_msg, strlen(help_help_msg));
      return;
    } else {
      // debug("break1");
      // FORMAT MSG DOES NOT WORK HERE.
      char help_extern_msg[PATH_MAX];
      snprintf(help_extern_msg, PATH_MAX, "%s: %s\n", commands[1],
               EXTERN_HELP_MSG);
      write(STDOUT_FILENO, help_extern_msg, strlen(help_extern_msg));
      return;
    }

  }

  else {

    // If no internal command is run, continue with fork.
    pid_t pid = fork();
    if (pid == -1) {
      const char *err = FORMAT_MSG("shell", FORK_ERROR_MSG);
      write(STDERR_FILENO, err, strlen(err)); // MAYBE CHANGE TO OUT?
    } else if (pid == 0 && commands[0] != NULL) {
      if (execvp(commands[0], commands) == -1) {
        // I think we use execvp so a path doesn't need to be specified
        // also because our arguments are in an array
        const char *err = FORMAT_MSG("shell", EXEC_ERROR_MSG);
        write(STDERR_FILENO, err, strlen(err));
      }
    } else {
      int wstatus = 0;
      if (!is_background) {
        if (waitpid(pid, &wstatus, 0) == -1) {
          // char *err = "shell: unable to wait for child\n";
          const char *err = FORMAT_MSG("shell", WAIT_ERROR_MSG);
          write(STDERR_FILENO, err, strlen(err));
        }
      }
    }
  }
}

// kills all currently running child processes.
// DEBUG: Check over later.
void kill_zombies() {
  int wstatus;
  while (waitpid(-1, &wstatus, WNOHANG) > 0) {
    continue;
  }
}

// Background Execution

int main() {
  shell();
  return 0;
}

#define _GNU_SOURCE
#include "../include/msgs.h"
#include <errno.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>





void shell() {
  char *current_line = NULL;
  size_t len = 0;
  ssize_t nread;

  // Variables for cwd
  long cwd_size;
  char *cwd_buf;
  char *cwd_ptr;

  while (true) {

    // Current Working Directory and shell stuff
    cwd_ptr = getcwd(cwd_buf, cwd_size);

    if (cwd_ptr == NULL) {
      printf("shell: unable to get current directory");
      cwd_ptr = "";
    }
    printf("%s$ ",
           cwd_ptr); // For reference, this is the shell path that's printed
    nread = getline(&current_line, &len, stdin);
    // printf("%s\n", current_line);

    // NEED A FREE FOR THE LINE THATS PASSED TO RUN_LINE
  }
}

// Foreground Execution
void run_line(char *line) {
  char *commands[4096]; // CHANGE THIS LATER ON
  char *saveptr;
  char *token = strtok_r(line, " ", &saveptr);
  int i = 0;

  while (token != NULL) {
    commands[i++] = token;
    token = strtok_r(NULL, " ", &saveptr);
  }

  pid_t pid = fork();

  if (pid == -1) {
    char* err = "shell: unable to fork";
    write(STDERR_FILENO, err, strlen(err)); // MAYBE CHANGE TO OUT? 
    exit(1);
  }
  else if (pid == 0) {
    if (execl( 
  }
  else {
    int wstatus = 0;
    if (waitpid(pid, &wstatus, 0) == -1) {
      char* err = "shell: unable to wait for child";
      write(STDERR_FILENO, err, strlen(err));
      exit(1);
    }
  }
}

// Background Execution

int main() {
  shell();
  return 0;
}

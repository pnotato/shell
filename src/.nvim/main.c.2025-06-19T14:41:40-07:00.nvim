#define _GNU_SOURCE
#include "../include/msgs.h"
#include <errno.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>

void run_line(char *line);

void shell() {
  char *current_line = NULL;
  size_t len = 0;
  ssize_t nread;

  // Variables for cwd
  long cwd_size;
  char *cwd_buf;
  char *cwd_ptr;

  while (true) {

    // Current Working Directory and shell stuff
    cwd_ptr = getcwd(cwd_buf, cwd_size);

    if (cwd_ptr == NULL) {
      printf("shell: unable to get current directory");
      cwd_ptr = "";
    }
    printf("%s$ ",
           cwd_ptr); // For reference, this is the shell path that's printed
    nread = getline(&current_line, &len, stdin);
    // printf("%s\n", current_line);

    run_line(current_line);
    // NEED A FREE FOR THE LINE THATS PASSED TO RUN_LINE
  }
}

// Foreground Execution
void run_line(char *line) {

  bool run_background = false;

  char *commands[4096]; // CHANGE THIS LATER ON
  char *saveptr;
  char *token = strtok_r(line, " \n", &saveptr);
  int i = 0;

  while (token != NULL) {
    commands[i++] = token;
    token = strtok_r(
        NULL, " \n",
        &saveptr); // \n is necessary should only one command be specified
  }
  if (i > 0 && strcmp(commands[i - 1], "&") == 0) {
    run_background = true;
    printf("DEBUG: BACKGROUND MODE IS ON\n");
    commands[i - 1] = NULL;
  } else {
    commands[i] = NULL; // Need to null terminate the array
  }

  pid_t pid = fork();

  if (pid == -1) {
    char *err = "shell: unable to fork\n";
    write(STDERR_FILENO, err, strlen(err)); // MAYBE CHANGE TO OUT?
    exit(1);
  } else if (pid == 0) {

    if (execvp(commands[0], commands) == -1) {

      // I think we use execvp so a path doesn't need to be specified
      // also because our arguments are in an array
      char *err = "shell: unable to execute command\n";
      write(STDERR_FILENO, err, strlen(err));
    }

  } else {
    int wstatus = 0;

    if (run_background) {
      printf("DEBUG: RUNNING IN BACKGROUND AND NOT WAITING");
    } else {
      if (waitpid(pid, &wstatus, 0) == -1) {
        char *err = "shell: unable to wait for child\n";
        write(STDERR_FILENO, err, strlen(err));
        exit(1);
      }
    }
  }
}

// Background Execution

int main() {
  shell();
  return 0;
}
